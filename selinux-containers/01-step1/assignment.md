---
slug: step1
id: twvu02rumsnm
type: challenge
title: Software installation and configuration
notes:
- type: text
  contents: |
    After completing this scenario, you will be able to run container images and generate SELinux profiles customized
    for your container usecases using Udica

    # Concepts included in this scenario:
    * Query the allow rules in the SELinux policy for the running container
    * Use Udica to generate SELinux security profiles for the container
    * Apply policy modules to the container based on the Common Intermediate Language (CIL) file generated by Udica
    * Re-query the allow rules in the SELinux policy for the running container to ensure that actions are allowed

    # Example Usecase:
    The default container type (container_t) is too restricted for certain usecases. For example, if Apache wants to read the home
    directory, it is restricted by default. Similarly, container_t is too loose for other cases. For example, the Apache running in
    the container can bind to any network port. Using udica can help you write a new SELinux security profiles that are customized for
    your container usecase, and does not require deep SELinux expertise to craft.
tabs:
- title: Terminal
  type: terminal
  hostname: rhel
- title: RHEL Web Console
  type: service
  hostname: rhel
  path: /
  port: 9090
difficulty: basic
timelimit: 3420
---

SELinux is a technology to isolate processes/containers running on the system to mitigate attacks which take
advantage of privilege escalation. Udica is a new tool which complements the containers tools (Podman, Skopeo, Buildah, etc.)
family supported by Red Hat to help improve the security of customers container environments.

>_NOTE:_ This lab assumes that you have a sound understanding of SELinux basics and container fundamentals.

Prior to getting started, we need certain packages such as Udica (which is a tool for generating
SELinux policies for containers), and setools-console (which is a set of tools that can facilitate
SELinux policy analysis). In this demo, the container runtime related packages are already installed.

>**Note:** In the `Terminal` tab in the upper left corner of the Instruqt web page, there are 2 shell sessions launched. To switch between the 2 shell sessions, press Ctrl-B and an arrow key pointing to the session you wish to become active.

First, go to pane 0.

![pane0](../assets/pane0.png)

Install the udica and setools-console packages on the container host

```bash
yum install -y udica setools-console
```

Get the latest RHEL9 UBI image

```bash
podman pull registry.access.redhat.com/ubi9/ubi:latest
```

Use `podman` to list the available container images

```bash
podman images
```

In 'Pane 1' of the lab interface, create a container runtime using podman which -
passes in-container accesses to /home through to the host's /home read-only, passes in-container
accesses to /var/spool through to the host's /var/spool read-write, and binds the
host's port 80 to pass traffic to the container's port 80.

```bash
CONTAINER=$(podman run -v /home:/home:ro -v /var/spool:/var/spool:rw -d -p 80:80 -it registry.access.redhat.com/ubi9/ubi)
```

>_NOTE:_ The home directory is mounted with read-only access, and the /var/spool/ directory is mounted with read-write access.

In 'Pane 0' of the lab interface, check the status of the application container using podman and get the running container id

```bash
podman ps; CONTAINERID=$(podman ps | grep registry.access.redhat.com | cut -b 1-12)
```

<pre class="file">
CONTAINER ID  IMAGE                         COMMAND               CREATED        STATUS           PORTS               NAMES
e47a11d3e2c5  registry.access.redhat.com/ubi9/ubi:latest  /bin/bash  3 seconds ago  Up 2 seconds ago0.0.0.0:80->80/tcp  naughty_golick
</pre>

When using SELinux, container processes get assigned a container type called 'container_t'. Verify the SELinux type assigned to the running container

```bash
ps -eZ | grep container_t
```

<pre class="file">
system_u:system_r:container_t:s0:c182,c1016 25755 pts/0 00:00:00 bash
</pre>

On Red Hat Enterprise Linux, SELinux is enabled by default and in enforcing mode.  You can confirm this by inspecting the output of `sestatus`
on the system.

```bash
sestatus
```

<pre class="file">
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             targeted
Current mode:                   enforcing
<< OUTPUT ABRIDGED >>
</pre>
